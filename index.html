<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WYFC61KVQZ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-WYFC61KVQZ');
    </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kerala Dam Water Levels</title>

    <meta name="description" content="Monitor real-time water levels of dams in Kerala. View interactive maps, charts, and historical data for Kerala's major dams. Stay informed about dam water storage, inflow, outflow, and rainfall.">
    <meta name="keywords" content="Kerala dams, water levels, dam storage, rainfall, inflow, outflow, interactive map, real-time data">
    <meta name="author" content="Amith V">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://damstats.amithv.xyz/">
    <meta property="og:title" content="Kerala Dam Water Levels | Real-time Monitoring">
    <meta property="og:description" content="Monitor real-time water levels of dams in Kerala. View interactive maps, charts, and historical data for Kerala's major dams.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://damstats.amithv.xyz/">
    <meta property="twitter:title" content="Kerala Dam Water Levels | Real-time Monitoring">
    <meta property="twitter:description" content="Monitor real-time water levels of dams in Kerala. View interactive maps, charts, and historical data for Kerala's major dams.">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://damstats.amithv.xyz/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/dam.png">


    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.3.0"></script>
    <style>
    </style>

    <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "n2sjfifq6d");
</script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Kerala Dam Water Levels </h1>
            <div class="circle"></div>
            <span id="lastUpdate"></span>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>
            <div class="mobile-header">
                <h1>Kerala Dam Water Levels</h1>
                <span id="mobileLastUpdate"></span>
            </div>
            <div id="sidebar">

                <button id="sortButton">Sort by Storage Percentage</button>
                <div id="damList"></div>
                <div id="chartContainer">
                    <canvas id="damChart"></canvas>
                </div>
            </div>
        </div>
        <div id="damDetails">
            <button id="closeButton">
                <svg width="20" height="20" viewbox="0 0 40 40">
                    <path d="M 10,10 L 30,30 M 30,10 L 10,30" stroke="black" stroke-width="4" />
                </svg>
            </button>
            <div id="damDetailsContent"></div>
            <div id="timeRangeSelectContainer">
                <select id="timeRangeSelect">
                    <option value="7">1 Week</option>
                    <option value="30" selected>1 Month</option>
                    <option value="60">2 Months</option>
                    <option value="90">3 Months</option>
                    <option value="180">6 Months</option>
                    <option value="365">1 Year</option>
                    <option value="730">2 Years</option>
                </select>
            </div>
            <div class="chart-container">
                <canvas id="waterLevelChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="storageChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="inflowChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="rainfallChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="dischargeChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
          const keralaBounds = L.latLngBounds([8.2878, 74.8559], [12.8183, 80.4122]);
          const map = L.map("map", {
            center: [9.8756, 77.0394],
            zoom: 11,
            minZoom: 7,
            maxBounds: keralaBounds,
            maxBoundsViscosity: 1.0,
          });
        
          L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          }).addTo(map);
        
          const elements = {
            damList: document.getElementById("damList"),
            lastUpdate: document.getElementById("lastUpdate"),
            mobileLastUpdate: document.getElementById("mobileLastUpdate"),
            sortButton: document.getElementById("sortButton"),
            damDetails: document.getElementById("damDetails"),
            damDetailsContent: document.getElementById("damDetailsContent"),
            closeButton: document.getElementById("closeButton"),
            timeRangeSelect: document.getElementById("timeRangeSelect"),
          };
        
          let dams = [];
          let chart;
          const markers = L.layerGroup().addTo(map);
          let selectedTimeRange = 30;
        
          const sortOptions = [
            { key: "storagePercentage", label: "Storage Percentage", chartType: "bar" },
            { key: "liveStorage", label: "Current Storage", chartType: "bar" },
            { key: "totalCapacity", label: "Total Capacity", chartType: "bar" },
            { key: "inflow", label: "Inflow", chartType: "line" },
            { key: "powerhouseDischarge", label: "Powerhouse Discharge", chartType: "line" },
            { key: "spillwayRelease", label: "Spillway Release", chartType: "line" },
            { key: "totalOutflow", label: "Total Outflow", chartType: "line" },
            { key: "rainfall", label: "Rainfall", chartType: "bar" },
            { key: "name", label: "Name", chartType: "bar" },
          ];
          let currentSortOption = sortOptions[0];
        
        
          // marker
          const createWaterLevelIcon = (percentage) => {
            return L.divIcon({
              className: "water-level-icon",
              html: `
                <div class="water-level-indicator">
                  <div class="water-level" style="height: ${percentage}%; background-color: ${getWaterLevelColor(percentage)};"></div>
                </div>
              `,
            });
          };
        
          const updateMarkers = () => {
            markers.clearLayers();
            dams.forEach((dam) => {
              const percentage = parseFloat(dam.data[0].storagePercentage);
              const marker = L.marker([dam.latitude, dam.longitude], {
                icon: createWaterLevelIcon(percentage),
              }).on("click", () => showDamDetails(dam));
        
              L.marker([dam.latitude, dam.longitude], {
                icon: L.divIcon({
                  className: "",
                  html: `<div class="dam-label">${dam.name}</div>`,
                }),
              }).addTo(markers);
        
              markers.addLayer(marker);
            });
          };
        
          //only show marker labels when zoomed in
          map.on("zoomend", () => {
            const currentZoom = map.getZoom();
            document.querySelectorAll(".dam-label").forEach((label) => {
              label.style.display = currentZoom >= 10 ? "block" : "none";
            });
          });
        
          const getWaterLevelColor = (percentage) => {
            const level = parseFloat(percentage);
            if (level < 20) return "#90EE90";
            if (level < 40) return "#ADFF2F";
            if (level < 60) return "#FFFF00";
            if (level < 80) return "#FFA500";
            return "#FF0000";
          };
        
          const formatUnits = {
            waterLevel: "m",
            liveStorage: "MCM",
            totalCapacity: "MCM",
            inflow: "cumecs",
            powerhouseDischarge: "cumecs",
            spillwayRelease: "cumecs",
            totalOutflow: "cumecs",
            rainfall: "mm",
            storagePercentage: "%",
          };
        
          const formatValue = (value, property) => {
            return typeof value === "number" && !isNaN(value)
              ? `${value.toFixed(2)}${formatUnits[property] || ""}`
              : property === "name"
              ? value
              : "N/A";
          };
        
          const fetchDamHistoricalData = async (damName) => {
            try {
              const response = await fetch(
                `https://raw.githubusercontent.com/amith-vp/Kerala-Dam-Water-Levels/main/historic_data/${encodeURIComponent(
                  damName.replace(/\s+/g, "_")
                )}.json`
              );
              return await response.json();
            } catch (error) {
              console.error("Error fetching historical dam data:", error);
              return null;
            }
          };
        
          // KSEB data contains inconsistent date formats, so the data for the last n days is fetched by calculating the number of days and then slicing the array for the last n days.
        
          const getDataForTimeRange = (data, days) => data.slice(-days);
        
          // Detailed dam information when clicked on a dam marker/name
          const showDamDetails = async (dam) => {
            const historicalData = await fetchDamHistoricalData(dam.name);
            if (historicalData) {
              elements.damDetailsContent.innerHTML = createDetailedContent(historicalData);
              historicalData.data.reverse();
              createWaterLevelChart(historicalData);
              createStorageChart(historicalData);
              createInflowChart(historicalData);
              createRainfallChart(historicalData);
              createDischargeChart(historicalData);
              elements.damDetails.style.display = "block";
            } else {
              alert("Failed to fetch historical data for this dam.");
            }
          };
        
          // sort option by time range
          elements.timeRangeSelect.addEventListener("change", (event) => {
            selectedTimeRange = parseInt(event.target.value);
            if (elements.damDetails.style.display === "block") {
              const activeDamName = elements.damDetailsContent.querySelector("h2").textContent.split(" (")[0];
              const activeDam = dams.find((dam) => dam.name === activeDamName);
              if (activeDam) {
                showDamDetails(activeDam);
              }
            }
          });
        
          // basic dam information from historic api
          const createDetailedContent = (damData) => {
            const latestData = damData.data[0];
            return `
              <div class="dam-details-container">
                <h2 class="dam-name">${damData.name}</h2>
                <div class="dam-info-grid">
                  <div class="dam-info-column">
                    <h4 class="info-section-title">Current Status</h4>
                    ${createInfoItem("Water Level", `${latestData.waterLevel} m`)}
                    ${createInfoItem("Storage", `${latestData.liveStorage} MCM (${latestData.storagePercentage})`)}
                    ${createInfoItem("Inflow", `${latestData.inflow} cumecs`)}
                    ${createInfoItem("Outflow", `${latestData.totalOutflow} cumecs`)}
                    ${createInfoItem("Rainfall", `${latestData.rainfall} mm`)}
                  </div>
                  <div class="dam-info-column">
                    <h4 class="info-section-title">Dam Specifications</h4>
                    ${createInfoItem("Maximum Water Level", `${damData.MWL} m`)}
                    ${createInfoItem("Full Reservoir Level", `${damData.FRL} m`)}
                    ${createInfoItem("Total Capacity", `${damData.liveStorageAtFRL} MCM`)}
                    ${createInfoItem("Red Alert Level", `${damData.redLevel} m`)}
                    ${createInfoItem("Orange Alert Level", `${damData.orangeLevel} m`)}
                  </div>
                </div>
              </div>
            `;
          };
        
          const createInfoItem = (label, value) => `
            <div class="dam-info-item">
              <strong class="info-label">${label}:</strong>
              <span class="info-value">${value}</span>
            </div>
          `;
        
          //chart js options
          const createChartOptions = (title, yAxisLabel, startAtZero, annotations = []) => ({
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: { display: true, text: title, color: "#e2e8f0" },
              tooltip: { mode: "index", intersect: false },
              annotation: {
                annotations: annotations.map((ann) => ({
                  type: "line",
                  yMin: ann.value,
                  yMax: ann.value,
                  borderColor: ann.borderColor,
                  borderWidth: 2,
                  label: {
                    content: ann.label,
                    enabled: true,
                    yAdjust: 10,
                    position: "start",
                    backgroundColor: "transparent",
                    color: ann.borderColor,
                  },
                })),
              },
            },
            scales: {
              y: {
                beginAtZero: startAtZero,
                ticks: { color: "#e2e8f0" },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                title: { display: true, text: yAxisLabel, color: "#e2e8f0" },
              },
              x: {
                reverse: true,
                ticks: { color: "#e2e8f0", maxRotation: 45, minRotation: 45 },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
              },
            },
          });
        
          const createChart = (ctx, type, data, options) => new Chart(ctx, { type, data, options });
        
          let waterLevelChart, storageChart, inflowChart, rainfallChart, dischargeChart;
        
          const createWaterLevelChart = (damData) => {
            const ctx = document.getElementById("waterLevelChart").getContext("2d");
            if (waterLevelChart) {
              waterLevelChart.destroy();
            }
        
        
            const filteredData = getDataForTimeRange(damData.data, selectedTimeRange);
        
            //max data is calculated to set maximum value of y axis (to fix FRL value not rendering in chart)
            const maxDataValue = Math.max(...filteredData.map((d) => parseFloat(d.waterLevel)));
            const frlValue = parseFloat(damData.FRL);
            const maxChartValue = Math.max(maxDataValue, frlValue);
            const yAxisMax = maxChartValue + 1;
        
            waterLevelChart = new Chart(ctx, {
              type: "line",
              data: {
                labels: filteredData.map((d) => d.date).reverse(),
                datasets: [
                  {
                    label: "Water Level (m)",
                    data: filteredData.map((d) => parseFloat(d.waterLevel)).reverse(),
                    borderColor: "rgb(75, 192, 192)",
                    tension: 0.1,
                  },
                ],
              },
              options: {
                ...createChartOptions(
                  "Water Level Over Time",
                  "Water Level (m)",
                  false,
                  [
                    { value: frlValue, label: "FRL", borderColor: "#1ABC9C" },
                    damData.orangeLevel
                      ? { value: parseFloat(damData.orangeLevel), label: "Orange Alert", borderColor: "#ff4d00" }
                      : null,
                    damData.redLevel
                      ? { value: parseFloat(damData.redLevel), label: "Red Alert", borderColor: "#ff0000" }
                      : null,
                  ].filter((annotation) => annotation !== null)
                ),
                scales: {
                  y: {
                    suggestedMax: yAxisMax,
                    display: true,
                    title: { display: true, text: "Water Level (m)" },
                  },
                  x: { reverse: true },
                },
              },
            });
          };
        
          const createStorageChart = (damData) => {
            const ctx = document.getElementById("storageChart").getContext("2d");
            if (storageChart) {
              storageChart.destroy();
            }
            const filteredData = getDataForTimeRange(damData.data, selectedTimeRange);
        
            storageChart = createChart(
              ctx,
              "line",
              {
                labels: filteredData.map((d) => d.date).reverse(),
                datasets: [
                  {
                    label: "Storage Percentage (%)",
                    data: filteredData.map((d) => parseFloat(d.storagePercentage)).reverse(),
                    borderColor: "rgb(255, 159, 64)",
                    tension: 0.1,
                  },
                ],
              },
              createChartOptions("Storage Over Time", "Storage Percentage (%)", true, [])
            );
          };
        
          const createInflowChart = (damData) => {
            const ctx = document.getElementById("inflowChart").getContext("2d");
            if (inflowChart) {
              inflowChart.destroy();
            }
            const filteredData = getDataForTimeRange(damData.data, selectedTimeRange);
        
            inflowChart = createChart(
              ctx,
              "line",
              {
                labels: filteredData.map((d) => d.date).reverse(),
                datasets: [
                  {
                    label: "Inflow (cumecs)",
                    data: filteredData.map((d) => parseFloat(d.inflow)).reverse(),
                    borderColor: "rgb(75, 192, 192)",
                    tension: 0.1,
                  },
                ],
              },
              createChartOptions("Inflow Over Time", "Flow (cumecs)", true)
            );
          };
        
          const createRainfallChart = (damData) => {
            const ctx = document.getElementById("rainfallChart").getContext("2d");
            if (rainfallChart) {
              rainfallChart.destroy();
            }
            const filteredData = getDataForTimeRange(damData.data, selectedTimeRange);
        
            rainfallChart = createChart(
              ctx,
              "bar",
              {
                labels: filteredData.map((d) => d.date).reverse(),
                datasets: [
                  {
                    label: "Rainfall (mm)",
                    data: filteredData.map((d) => parseFloat(d.rainfall)).reverse(),
                    backgroundColor: "rgba(54, 162, 235, 0.5)",
                    borderColor: "rgb(54, 162, 235)",
                    borderWidth: 1,
                  },
                ],
              },
              createChartOptions("Rainfall Over Time", "Rainfall (mm)", true)
            );
          };
        
          const createDischargeChart = (damData) => {
            const ctx = document.getElementById("dischargeChart").getContext("2d");
            if (dischargeChart) {
              dischargeChart.destroy();
            }
            const filteredData = getDataForTimeRange(damData.data, selectedTimeRange);
        
            dischargeChart = createChart(
              ctx,
            "line",
            {
              labels: filteredData.map((d) => d.date).reverse(),
              datasets: [
                {
                  label: "Powerhouse Discharge (cumecs)",
                  data: filteredData.map((d) => parseFloat(d.powerHouseDischarge)).reverse(),
                  borderColor: "rgb(255, 206, 86)",
                  tension: 0.1,
                },
                {
                  label: "Spillway Release (cumecs)",
                  data: filteredData.map((d) => parseFloat(d.spillwayRelease)).reverse(),
                  borderColor: "rgb(75, 192, 192)",
                  tension: 0.1,
                },
                {
                  label: "Total Outflow (cumecs)",
                  data: filteredData.map((d) => parseFloat(d.totalOutflow)).reverse(),
                  borderColor: "rgb(255, 99, 132)",
                  tension: 0.1,
                },
              ],
            },
            createChartOptions("Discharge Over Time", "Discharge (cumecs)", true)
          );
          };
        
          // dam details from live API
          const updateDamList = () => {
          elements.damList.innerHTML = dams
            .map(
              (dam) => {
                const redLevel = parseFloat(dam.redLevel);
                const orangeLevel = parseFloat(dam.orangeLevel);
                const blueLevel= parseFloat(dam.blueLevel);
                const waterLevel = parseFloat(dam.data[0].waterLevel);
                console.log(waterLevel, redLevel, orangeLevel, blueLevel);
                let alert = ``;
        
                if (waterLevel >= redLevel) {
                  alert  = `<div class="red-badge">ALERT</div>`;
                } else if (waterLevel >= orangeLevel) {
                  alert  = `<div class="orange-badge">ALERT</div>`;
                } else if (waterLevel >= blueLevel) {
                  alert  = `<div class="blue-badge">ALERT</div>`;
        
                }
        
                return `
                  <div class="card dam-item" data-name="${dam.name}">
                      <div class="card-content">
                        <div class="flex items-center gap-3">
                          <h3>${dam.name}</h3>
                        </div>
                        <div class="relative">
                        ${alert}
                        <div class="power-output">${formatValue(getPropertyValue(dam, currentSortOption.key),currentSortOption.key)}</div>
                      </div>
                    </div>
                  </div>
                `;
              }
            ).join("");
        
          document.querySelectorAll(".dam-item").forEach((item) => {
            item.addEventListener("click", () => {
              const damName = item.dataset.name;
              const dam = dams.find((d) => d.name === damName);
              showDamDetails(dam);
            });
          });
        };
        
          const propertyGetters = {
            name: (dam) => dam.name,
            storagePercentage: (dam) => parseFloat(dam.data[0].storagePercentage),
            waterLevel: (dam) => parseFloat(dam.data[0].waterLevel),
            liveStorage: (dam) => parseFloat(dam.data[0].liveStorage),
            totalCapacity: (dam) => parseFloat(dam.liveStorageAtFRL),
            inflow: (dam) => parseFloat(dam.data[0].inflow),
            powerhouseDischarge: (dam) => parseFloat(dam.data[0].powerHouseDischarge),
            spillwayRelease: (dam) => parseFloat(dam.data[0].spillwayRelease),
            totalOutflow: (dam) => parseFloat(dam.data[0].totalOutflow),
            rainfall: (dam) => parseFloat(dam.data[0].rainfall),
          };
        
          const getPropertyValue = (dam, property) => {
            const getter = propertyGetters[property];
            return getter ? getter(dam) : 0;
          };
        
          // chart based on sort option
          const updateChart = () => {
            const ctx = document.getElementById("damChart").getContext("2d");
            if (chart) {
              chart.destroy();
            }
        
            let chartData, config;
        
            if (currentSortOption.key === "name") {
              const waterLevels = dams.map((dam) => parseFloat(dam.data[0].storagePercentage));
              const data = [0, 20, 40, 60, 80].map(
                (threshold, index, arr) =>
                  waterLevels.filter((l) => l > threshold && l <= (arr[index + 1] || 100)).length
              );
        
              chartData = {
                labels: ["0-20%", "21-40%", "41-60%", "61-80%", "81-100%"],
                datasets: [
                  {
                    label: "Number of Dams",
                    data: data,
                    backgroundColor: ["#90EE90", "#ADFF2F", "#FFFF00", "#FFA500", "#FF0000"],
                  },
                ],
              };
        
              config = {
                type: "bar",
                data: chartData,
                options: createChartOptions("Dam Water Level Distribution"),
              };
            } else {
              const top7Dams = dams.slice(0, 7);
              const labels = top7Dams.map((dam) => dam.name);
              const data = top7Dams.map((dam) => getPropertyValue(dam, currentSortOption.key));
        
              chartData = {
                labels: labels,
                datasets: [
                  {
                    label: currentSortOption.label,
                    data: data,
                    backgroundColor: getChartColors(data.length),
                    borderColor: getChartColors(data.length),
                    borderWidth: 1,
                  },
                ],
              };
        
              config = {
                type: currentSortOption.chartType,
                data: chartData,
                options: createChartOptions(currentSortOption.label),
              };
            }
        
            chart = new Chart(ctx, config);
          };
        
          const getChartColors = (count) => {
            const baseColors = ["#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0", "#9966FF", "#FF9F40", "#FF6B6B"];
            return baseColors.slice(0, count);
          };
        
          const addWaterLevelLegend = () => {
            const legend = L.control({ position: "topright" });
            legend.onAdd = () => {
              const div = L.DomUtil.create("div", "water-level-legend");
              div.innerHTML = `
                <h4>Water Level Scale</h4>
                ${[0, 20, 40, 60, 80]
                  .map(
                    (threshold, index) => `
                    <div class="water-level-item">
                      <span class="water-level-color" style="background-color: ${getWaterLevelColor(threshold + 1)};"></span>
                      ${threshold + 1}-${index === 4 ? 100 : threshold + 20}%
                    </div>
                  `
                  )
                  .join("")}
              `;
              return div;
            };
            legend.addTo(map);
          };
        
          elements.sortButton.addEventListener("click", () => {
            const currentIndex = sortOptions.indexOf(currentSortOption);
            currentSortOption = sortOptions[(currentIndex + 1) % sortOptions.length];
            elements.sortButton.textContent = `Sort by ${currentSortOption.label}`;
        
            dams.sort((a, b) =>
              currentSortOption.key === "name"
                ? a.name.localeCompare(b.name)
                : getPropertyValue(b, currentSortOption.key) - getPropertyValue(a, currentSortOption.key)
            );
            updateDamList();
            updateChart();
          });
        
          const fetchDamData = async () => {
            try {
              const response = await fetch(
                "https://raw.githubusercontent.com/amith-vp/Kerala-Dam-Water-Levels/main/live.json"
              );
              const data = await response.json();
              dams = data.dams;
              const lastUpdateText = `Last Updated: ${data.lastUpdate}`;
              elements.lastUpdate.textContent = lastUpdateText;
              elements.mobileLastUpdate.textContent = lastUpdateText;
              dams.sort(
                (a, b) =>
                  getPropertyValue(b, currentSortOption.key) - getPropertyValue(a, currentSortOption.key)
              );
              updateDamList();
              updateChart();
              updateMarkers();
            } catch (error) {
              console.error("Error fetching dam data:", error);
            }
          };
        
          elements.closeButton.addEventListener("click", () => {
            elements.damDetails.style.display = "none";
          });
        
          fetchDamData();
          addWaterLevelLegend();
        });
    </script>
</body>

</html>
